# 🧮 백준 15649번 - N과 M (1) (DFS, Backtracking)
> 📂 카테고리: Silver III / 백트래킹, DFS

---

## 📘 문제

자연수 N과 M이 주어졌을 때,  
1부터 N까지 자연수 중에서 **중복 없이 M개를 고른 수열**을  
**모두 출력**하는 프로그램을 작성하시오.

### 📜 조건 요약

- 1 ≤ M ≤ N ≤ 8  
- 1부터 N까지 자연수 중에서 중복 없이 선택  
- 선택된 수열은 **오름차순이 아님** (즉, 순열)  
- 출력은 **사전 순**으로 정렬되어야 함

---

## 🔢 입력

- 첫째 줄: 두 정수 `N`, `M`이 공백으로 구분되어 주어진다.

---

## 📤 출력

- 한 줄에 하나씩, 가능한 **길이 M의 순열**을 공백으로 구분하여 출력한다.

---

## 💡 핵심 개념

- **DFS (Depth-First Search)** 기반 **백트래킹(Backtracking)** 문제  
- “현재 선택한 수열의 깊이(depth)”가 `M`이 되면 출력  
- 각 단계에서 1부터 N까지 순회하며  
  **방문하지 않은 수(`!visited[i]`)만 선택**  
- 재귀 호출 후에는 `pop_back()` + `visited[i] = false`로  
  **상태 복원 (Backtracking)**

---

## 🧱 구조 설계

### 🧩 주요 전역 변수

```cpp
int N, M;
vector<int> v;
bool visited[9];
```

---

## ⚠️ 주의사항

| 항목 | 설명 |
|------|------|
| ⚡ `visited[]` | 이미 사용한 숫자는 다시 사용하지 않도록 관리 |
| ♻️ **백트래킹** | `push_back()` 후 반드시 `pop_back()`으로 복원 |
| 🧮 **재귀 깊이** | `depth == M`일 때 수열 완성 |
| 🚀 **I/O 최적화** | `ios::sync_with_stdio(false); cin.tie(nullptr);` |

---

## 📊 복잡도 분석

| 항목 | 복잡도 | 설명 |
|------|---------|------|
| ⏱ **시간 복잡도** | O(NPm) ≈ O(N!) | 가능한 모든 순열 탐색 |
| 💾 **공간 복잡도** | O(M) | 벡터 및 방문 배열 사용 |

---

## 💭 느낀점

이 문제는 **백트래킹(Backtracking)**의 기본 형태를 익히기에 완벽하다.  
단순한 반복문이 아닌, 재귀를 통한 모든 가능한 경우의 수 탐색 과정을  
직접 구현하면서 DFS의 흐름을 명확히 이해할 수 있었다.  

특히 `visited` 배열을 통해 중복을 제거하고,  
`push` → `재귀` → `pop`의 순서를 반복하며  
상태를 복원하는 과정이 핵심이었다.  

이 로직은 향후 **조합, 순열, 부분수열, 그래프 탐색** 문제에서도  
기본 뼈대로 활용될 수 있는 중요한 패턴이다. 💪

---

## 🧩 결과 요약표

| 항목 | 내용 |
|------|------|
| **문제 번호** | 15649 |
| **문제 이름** | N과 M (1) |
| **난이도** | Silver III |
| **사용 언어** | C++ |
| **알고리즘 분류** | 백트래킹, DFS |
| **핵심 개념** | 중복 없는 순열 생성 |
| **시간 복잡도** | O(N!) |
| **공간 복잡도** | O(M) |
| **출력 형태** | 가능한 모든 순열을 한 줄씩 출력 |
| **학습 포인트** | DFS + 상태 복원 (Backtracking) 기본 패턴 |

