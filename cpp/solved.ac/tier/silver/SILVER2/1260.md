# 🚀 BOJ 1260 — DFS와 BFS

> 📂 **카테고리:** 그래프 탐색 (DFS, BFS)  
> 💻 **언어:** C++  
> 🏷️ **태그:** DFS, BFS, Graph, Recursion, Queue, BOJ1260, Silver II, C++, 탐색, ConnectedComponents

---

## 🧩 문제

그래프를 DFS(깊이 우선 탐색)과 BFS(너비 우선 탐색)로 탐색한 결과를 출력하는 프로그램을 작성하시오.  
단, 방문할 수 있는 정점이 여러 개인 경우, **정점 번호가 작은 것부터** 방문한다.

---

## 📥 입력

첫째 줄에 정점의 개수 `N`, 간선의 개수 `M`, 탐색을 시작할 정점 번호 `V`가 주어진다.  
둘째 줄부터 M개의 줄에는 간선이 연결하는 두 정점의 번호 `a`, `b`가 주어진다.  
(양방향 그래프)


---

## 📤 출력

첫째 줄에 **DFS** 수행 결과,  
둘째 줄에 **BFS** 수행 결과를 출력한다.


---

## 🧠 핵심 개념

| 개념 | 설명 |
|------|------|
| **DFS (Depth First Search)** | 한 노드에서 출발해 깊게 들어가며 탐색하는 방식. 재귀 또는 스택 사용. |
| **BFS (Breadth First Search)** | 한 노드에서 출발해 가까운 노드부터 탐색하는 방식. 큐 사용. |
| **인접 리스트 (Adjacency List)** | 각 정점에 연결된 노드를 리스트로 표현. 메모리 효율적. |
| **방문 배열 (visited)** | 방문 여부를 체크하여 중복 탐색 방지. |

---

## 🧭 접근 방법

1. **그래프 표현:**  
   `vector<Node*>`를 사용하여 각 노드의 연결관계를 인접 리스트로 저장.  
2. **DFS 구현:**  
   재귀 함수를 통해 방문하지 않은 노드를 깊이 우선으로 탐색.  
3. **BFS 구현:**  
   큐를 사용하여 가까운 정점부터 차례로 탐색.  
4. **정렬 처리:**  
   정점 번호가 작은 것부터 방문해야 하므로 `sort()`로 인접 리스트 정렬.  
5. **visited 배열 초기화:**  
   DFS 이후 BFS를 수행할 때 다시 초기화 필요.

---

## 📊 복잡도 분석

| 항목 | 복잡도 | 설명 |
|------|---------|------|
| ⏱ **시간 복잡도** | O(N + M) | 모든 정점과 간선을 한 번씩 방문 (DFS/BFS 동일) |
| 💾 **공간 복잡도** | O(N + M) | 인접 리스트, 방문 배열, 큐/스택 공간 포함 |
| ⚙️ **DFS 재귀 비용** | O(H) | H = 연결된 정점 수 (최대 N) |
| 🚀 **탐색 구조** | DFS(재귀) + BFS(큐) 기반 그래프 탐색 |
| 🔁 **최적화 요소** | 방문 배열(visited)로 중복 방문 방지, 정점 오름차순 정렬 |
| ⚡ **입출력 최적화** | `ios::sync_with_stdio(false); cin.tie(nullptr);` 사용 |

---

## 🧩 결과 요약표

| 항목 | 내용 |
|------|------|
| 🧾 **문제 번호** | 1260 |
| 📛 **문제 이름** | DFS와 BFS |
| 🥇 **난이도** | Silver II |
| 💻 **사용 언어** | C++ |
| 🧠 **알고리즘 분류** | 그래프 탐색, DFS, BFS |
| 🧩 **핵심 개념** | 정점 간 인접 리스트를 통한 깊이/너비 우선 탐색 |
| ⏱ **시간 복잡도** | O(N + M) |
| 💾 **공간 복잡도** | O(N + M) |
| ⚙️ **탐색 방식** | DFS: 재귀 / BFS: 큐 |
| 📤 **출력 형태** | DFS 결과 1줄 + BFS 결과 1줄 |
| 🎯 **학습 포인트** | DFS/BFS 구조적 차이 및 인접 리스트 구현 패턴 |

---

## 💬 느낀점

> DFS와 BFS의 차이를 코드로 직접 구현하며,  
> **재귀 vs 큐 구조**의 흐름을 명확히 이해할 수 있었다.  
> 특히 방문 순서를 오름차순으로 맞추기 위한 `sort()` 정렬이 핵심 포인트였다.  
>  
> 단순 탐색이라도 구조체(`Node`)와 클래스(`Graph`)로 설계하면  
> **확장성과 가독성**이 확실히 좋아진다는 점을 체감했다.
