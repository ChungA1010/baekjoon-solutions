# 🧮 백준 1874 - 스택 수열 (Stack Sequence)

---

## 📖 문제
1부터 N까지의 수를 스택에 넣었다가 뺄 수 있다.  
입력으로 주어진 수열이 이러한 **스택 연산(push, pop)**으로 만들어질 수 있는지 판별하고,  
가능하다면 **연산의 순서를 출력**하는 프로그램을 작성하시오.

---

## 🔢 입력
- 첫째 줄에 수열의 크기 **N (1 ≤ N ≤ 100,000)**  
- 둘째 줄부터 N개의 줄에는 **수열의 각 원소**가 주어진다.  
- 입력되는 수열은 1부터 N까지의 수로 이루어진 **임의의 순열**이다.

---

## 📤 출력
- 가능한 경우: 스택에 **push한 경우 `+`**, pop한 경우 `-` 를 한 줄씩 출력한다.  
- 불가능한 경우: `"NO"`를 출력한다.

---

## 💡 핵심 개념
1. **스택(Stack)** 은 LIFO(Last In First Out) 구조로, 가장 최근에 들어온 값이 먼저 나간다.
2. **현재 숫자(cur)** 를 1부터 시작해서 `target` 값에 도달할 때까지 push.
3. `cur`이 `target`을 초과하면 pop만 수행.
4. 스택의 top이 `target`과 다르면 해당 수열은 만들 수 없다.

---

## 🧭 접근 방법
1. `cur` 변수를 1로 초기화한다. (다음에 push할 숫자)
2. 입력받은 각 `target`에 대해 다음을 반복한다:
   - `cur <= target`인 동안, 스택에 push하고 `cur++`한다.
   - 스택의 top이 `target`이면 pop 수행.
   - 아니라면 수열을 만들 수 없으므로 `"NO"` 출력 후 종료.
3. 모든 입력을 처리하면 저장된 연산(`+`, `-`)을 순서대로 출력한다.

---

## 📊 복잡도 분석

| 구분 | 복잡도 | 설명 |
|------|---------|------|
| **시간 복잡도** | `O(N)` | 각 숫자는 최대 1회 push, 1회 pop 수행 |
| **공간 복잡도** | `O(N)` | 스택(`vector`)에 최대 N개의 원소 저장 가능 |

💡 **설명 요약**
- 각 숫자는 한 번씩만 스택에 들어갔다 나오므로 `O(N)`의 선형 시간.  
- 별도의 배열이나 추가 구조가 없고, 스택 공간만 필요하므로 `O(N)` 메모리 사용.
- N ≤ 100,000이므로 충분히 빠르고 효율적인 알고리즘이다.


---

## ⚠️ 주의사항

1. **스택이 비어있을 때 pop을 시도하면 런타임 에러** 발생  
   → 반드시 `!nums.empty()`를 먼저 확인해야 함.
2. `if(cur == target)`이 아닌 `if(nums.back() == target)` 사용  
   → 실제 스택의 top 값과 입력값이 일치해야 pop 가능.
3. **입출력 속도 최적화**  
   → `ios::sync_with_stdio(false);`  
     `cin.tie(nullptr);` 를 꼭 추가.
4. **불가능한 경우 즉시 종료**  
   → `"NO"` 출력 후 `return 0;` 해야 불필요한 연산 방지.
5. **출력 문자열 누적 시 개행 포함 주의**  
   → `"+"` 또는 `"-"` 뒤에 `"\n"`을 꼭 붙여야 줄바꿈 형식이 맞음.
