# ♟️ 백준 9663번 - N-Queen (백트래킹 완전탐색)

> 🧩 **문제 유형:** 백트래킹 / 브루트포스  
> 🧮 **난이도:** Gold IV  
> 🕒 **시간 제한:** 2초  
> 💾 **메모리 제한:** 128 MB  

---

## 📘 문제 설명

N × N 크기의 체스판 위에 **N개의 퀸(Queen)**을 서로 공격하지 않게 놓는 경우의 수를 구하는 문제이다.  
퀸은 체스에서 **같은 행, 같은 열, 두 대각선 방향으로 공격할 수 있는 말**이다.

즉, 아래 조건을 모두 만족해야 한다.

- 같은 **행(Row)** 에 2개 이상의 퀸이 있으면 안 된다.  
- 같은 **열(Column)** 에 2개 이상의 퀸이 있으면 안 된다.  
- 같은 **대각선(Diagonal)** 위에 2개 이상의 퀸이 있으면 안 된다.

---

## 💡 아이디어

1. **행(row)** 을 기준으로 재귀(DFS)를 수행한다.  
2. 각 행에는 **퀸 하나만** 놓을 수 있다.  
3. 퀸을 놓을 때,  
   - 같은 열(`col[c]`)  
   - ↘ 대각선(`diag1[row + c]`)  
   - ↙ 대각선(`diag2[row - c + N - 1]`)  
   이 3가지 중 어느 곳에도 다른 퀸이 없어야 한다.  
4. 조건을 만족하면 다음 행(`row + 1`)으로 이동한다.  
5. 모든 행(`row == N`)에 퀸을 배치하면 경우의 수(`cnt++`)를 증가시킨다.  
6. **백트래킹(backtracking)** 으로 탐색을 되돌려 다른 경우를 시도한다.

---

## 🧠 핵심 개념 정리

| 개념 | 설명 |
|------|------|
| **col[c]** | c번째 열에 퀸이 존재하는가 |
| **diag1[row + c]** | ↘ 방향 대각선에 퀸이 존재하는가 |
| **diag2[row - c + N - 1]** | ↙ 방향 대각선에 퀸이 존재하는가 |
| **row** | 현재 탐색 중인 행 번호 |
| **cnt** | 가능한 퀸 배치의 총 개수 |

---

## 🔍 시간 복잡도 분석

| 항목 | 설명 | 복잡도 |
|------|------|---------|
| 퀸 배치 탐색 | 각 행에서 가능한 열을 탐색 (최대 N개) | O(N!) 근사 |
| 대각선 체크 | col / diag 배열 접근 | O(1) |
| 전체 공간 | boolean 배열 3개 (최대 30칸) | O(N) |

---

## 🧮 성능 요약

| N | 결과(경우의 수) |
|---|------------------|
| 4 | 2 |
| 5 | 10 |
| 6 | 4 |
| 7 | 40 |
| 8 | 92 |
| 9 | 352 |
| 10 | 724 |

---

## 🧭 느낀점

- 처음에는 2차원 배열로 전체 체스판을 시뮬레이션하려 했지만,  
  **열/대각선만 추적하면 훨씬 간단하게 해결 가능**함을 배웠다.  
- 백트래킹의 핵심은 **되돌리기 (unmark)** 이며,  
  상태를 복구하지 않으면 다른 탐색 가지를 찾을 수 없다는 점이 중요하다.  
- 완전탐색이지만, 각 단계에서 불가능한 경로를 **즉시 가지치기(Pruning)** 하기 때문에  
  실제 수행 시간은 매우 효율적이다.  
- 체스판의 시각적 구조보다 **논리적 제약조건의 수학적 표현(대각선 관계)** 이  
  알고리즘 최적화의 핵심 포인트임을 체감했다.

---

## 🧮 복잡도 & 결과 요약표

| 구분 | 내용 |
|------|------|
| 시간 복잡도 | O(N!) |
| 공간 복잡도 | O(N) |
| 핵심 로직 | 백트래킹 (DFS) |
| 사용 자료구조 | bool 배열 3개 |
| 알고리즘 패턴 | 재귀 + 가지치기 |
| 주요 아이디어 | 열·대각선 중복 방지 및 상태 복구 |

---

## ✨ 결론

- **N-Queen 문제는 백트래킹의 정석 예제**로,  
  "탐색"과 "되돌리기"의 개념을 동시에 익힐 수 있다.  
- 단순한 완전탐색이지만, **효율적인 제약 조건 관리(col, diag)** 를 통해  
  탐색 공간을 크게 줄일 수 있다.  
- 본 코드는 명확하고 직관적인 백트래킹 구조를 유지하면서도  
  O(N!)에 근접한 효율을 달성한다.  
- 이후 확장으로 **비트마스크 최적화 버전**을 적용하면  
  N=15 이상에서도 빠르게 동작하는 고급형 풀이로 발전시킬 수 있다 🚀
