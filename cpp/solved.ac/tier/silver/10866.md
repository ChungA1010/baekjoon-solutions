# 🧮 백준 10866번 - 덱 (Deque, Linked List Implementation)
> 📂 카테고리: Silver IV / 덱, 자료구조, 연결 리스트  
---

## 📘 문제

정수를 저장하는 덱(Deque)을 구현하고, 주어진 명령을 처리하는 프로그램을 작성하시오.  
덱은 **양쪽 끝(front/back)** 에서 삽입과 삭제가 모두 가능한 자료구조이다.  

### 명령어 목록
- `push_front X`: 정수 X를 덱의 앞에 넣는다.  
- `push_back X`: 정수 X를 덱의 뒤에 넣는다.  
- `pop_front`: 가장 앞의 정수를 빼고 출력. 없으면 -1 출력.  
- `pop_back`: 가장 뒤의 정수를 빼고 출력. 없으면 -1 출력.  
- `size`: 덱에 들어있는 정수의 개수를 출력.  
- `empty`: 비어 있으면 1, 아니면 0 출력.  
- `front`: 가장 앞의 정수를 출력. 없으면 -1 출력.  
- `back`: 가장 뒤의 정수를 출력. 없으면 -1 출력.

---

## 🔢 입력

- 첫째 줄: 명령의 개수 `N (1 ≤ N ≤ 2,000,000)`  
- 둘째 줄부터: 한 줄에 하나씩 명령이 주어진다.  
- 정수 X는 `1 ≤ X ≤ 100,000` 범위이다.

---

## 📤 출력

각 명령의 실행 결과를 순서대로 한 줄에 하나씩 출력한다.  
단, `push_front`와 `push_back`은 출력하지 않는다.

---

## 💡 핵심 개념

- **덱(Deque)**: Double Ended Queue  
  → **양쪽에서 삽입/삭제가 모두 가능한 구조**  
- 배열 대신 **이중 연결 리스트(Double Linked List)** 로 구현하여  
  `push_front`, `push_back`, `pop_front`, `pop_back` 모두 **O(1)**로 수행  
- 각 노드는 `prev`, `next` 포인터를 가지며,  
  `front`와 `back` 포인터로 양끝 노드를 추적한다.  
- 명령이 많으므로 `ostringstream`을 이용해 **출력 버퍼링** 처리

---

## 🧭 접근 방법

1. `Node` 구조체 생성  
   ```cpp
   struct Node {
       int value;
       Node* prev;
       Node* next;
   };
   ```
2. `Deque` 구조체 설계  
   - 멤버: `Node* front`, `Node* back`, `int size`  
   - 동작 메서드:
     - `push_front(X)` → 새 노드를 만들어 맨 앞에 연결  
     - `push_back(X)` → 새 노드를 만들어 맨 뒤에 연결  
     - `pop_front()` → 맨 앞 노드를 제거 후 값 반환  
     - `pop_back()` → 맨 뒤 노드를 제거 후 값 반환  
     - `Front() / Back()` → 양끝 노드의 값 출력  
     - `Empty()` → 크기가 0이면 1, 아니면 0  
3. 명령문 파싱  
   - `switch(S[0])`, `switch(S[1])`, `switch(S[4])` 등을 이용해  
     문자열 비교 없이 빠르게 분기 처리  
4. 결과는 `ostringstream out` 에 누적 후,  
   마지막에 `cout << out.str();` 한 번만 출력  

---

## ⚠️ 주의사항

- **front == nullptr** 상태는 덱이 비어 있음을 의미한다.  
- 비어 있을 때 `pop_front`, `pop_back`, `front`, `back` 호출 시 **-1 출력**  
- **메모리 누수 방지**: pop 시 `delete temp;`로 동적 메모리 해제 필수  
- **출력 속도**: `ostringstream` 사용으로 I/O 병목 최소화  
- 문자열 비교 대신 `switch-case`로 성능 향상  

---

## 📊 복잡도 분석

| 항목 | 복잡도 | 설명 |
|------|---------|------|
| ⏱ **시간 복잡도** | O(N) | 각 명령어 1회 처리 |
| 💾 **공간 복잡도** | O(N) | 동적 노드(N개) + 출력 버퍼 |
| ⚙️ **입출력 속도** | O(N) | 결과를 버퍼에 저장 후 한 번에 출력 |

---

## 💭 느낀점

이번 문제는 배열이 아닌 **연결 리스트로 덱을 구현**한 점에서 큰 의미가 있었다.  
`push_front`, `push_back` 모두 **O(1)**로 수행되면서도  
메모리 관리와 포인터 연결을 직접 다뤄야 해서 C++의 구조적 이해가 깊어졌다.  

또한 문자열 비교 대신 **switch-case 문자 기반 파싱**으로  
최대 2,000,000개의 명령도 충분히 빠르게 처리할 수 있었다.  
STL 없이 덱을 직접 설계해보며,  
자료구조의 근본적인 동작 원리를 체감할 수 있었던 좋은 문제였다 💪

---

## 🧩 결과 요약표

| 항목 | 내용 |
|------|------|
| **문제 번호** | 10866 |
| **문제 이름** | 덱 (Deque) |
| **난이도** | Silver IV |
| **사용 언어** | C++ |
| **알고리즘 분류** | 덱, 자료구조, 연결 리스트 |
| **핵심 개념** | 양방향 연결 리스트 기반 덱 구현 |
| **시간 복잡도** | O(N) |
| **공간 복잡도** | O(N) |
| **실패 조건** | 비어 있는 상태에서 pop/front/back 호출 |
| **입출력 최적화** | `ios::sync_with_stdio(false); cin.tie(nullptr);` |
| **출력 형태** | 각 명령어 결과를 한 줄씩 출력 (push 제외) |
| **학습 포인트** | 포인터 연결, 동적 메모리 관리, switch-case 명령 처리 |
