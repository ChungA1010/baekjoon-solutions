# 📘 BOJ 4948 — 베르트랑 공준

## 📖 문제 개요
자연수 **n**이 주어졌을 때,  
**n보다 크고 2n 이하인 소수(prime number)** 가 몇 개인지를 구하는 문제.

입력은 여러 개의 n으로 주어지고,  
`0`이 입력되면 프로그램이 종료됩니다.

---

## 📥 입력
- 각 줄에 정수 n (1 ≤ n ≤ 123,456)이 주어짐.
- 마지막 입력은 `0`.

## 📤 출력
- 각 n에 대해 `(n, 2n]` 구간에 존재하는 **소수의 개수**를 한 줄씩 출력.

---

## 🧠 핵심 개념
> **베르트랑 공준 (Bertrand’s postulate)**  
> 1보다 큰 모든 자연수 n에 대해,  
> n보다 크고 2n 이하인 소수가 항상 존재한다.

이 문제는 이 공준을 **직접 계산으로 확인**하는 문제입니다.

---

## 💡 접근 방법

### ✅ 방법 1 — 단순 소수 판별
- 각 수마다 `√n`까지 나누어 보며 소수인지 검사.  
- 하지만 n이 123,456까지 가능하므로 **시간 초과** 가능성이 큼.

### ✅ 방법 2 — 에라토스테네스의 체 (권장)
- 2n까지의 모든 소수를 한 번에 미리 구함.
- 이후 입력받은 n마다 `(n, 2n]` 범위의 소수 개수를 세면 됨.
- 한 번만 계산하면 여러 입력에 재사용 가능 → 매우 효율적.

---

## ⏱️ 복잡도 분석

| 단계 | 시간 복잡도 |
|------|---------------|
| 에라토스테네스의 체 | O(N log log N) |
| 각 n 처리 | O(N) |
| 전체 | O(N log log N) |

---

## ⚠️ 주의 사항
- `(n, 2n]` → n은 **포함하지 않고**, 2n은 **포함**한다.
- 1은 소수가 아니다.
- 여러 번 입력되므로 `ios::sync_with_stdio(false); cin.tie(nullptr);` 설정 권장.
- 매 루프마다 카운트 변수(`sum`) 초기화 필요.
