# 🥬 BOJ 1012 - 유기농 배추

---

## 📌 문제
어느 농장에 배추들이 심어져 있다.  
상하좌우로 인접한 배추들은 하나의 배추 군집을 형성하며,  
각 군집마다 해충 방지를 위한 지렁이가 한 마리씩 필요하다.  

즉, 주어진 밭에서 서로 인접한 배추들의 덩어리(connected component)가  
몇 개인지 구하는 프로그램을 작성하라.

---

## 📥 입력
- 첫 줄에 테스트 케이스의 개수 **T**  
- 각 테스트 케이스마다  
  - 첫 줄: 밭의 가로 길이 **M**, 세로 길이 **N**, 배추의 개수 **K**  
  - 다음 **K**줄: 배추가 심어진 좌표 **(X, Y)**

📘 단, (0 ≤ X < M, 0 ≤ Y < N)

---

## 📤 출력
- 각 테스트 케이스마다 필요한 **지렁이의 수**를 한 줄에 출력한다.

---

## 🧩 핵심 개념
- **그래프 탐색(DFS/BFS)** 문제  
- 격자형 그래프에서의 **연결 요소(Connected Component)** 탐색  
- 인접한 배추끼리 상하좌우로 연결되어 있음  
- DFS 또는 BFS로 방문 표시하며 군집 개수를 카운트  

---

## 🧭 접근 방법
1. 입력 크기 M×N 크기의 2D 테이블 생성  
2. 배추 위치 `(X, Y)`를 true로 표시  
3. 모든 칸을 순회하면서  
   - 아직 방문하지 않은 true인 칸 발견 시 DFS 시작  
   - DFS로 상하좌우 연결된 모든 배추를 방문 처리  
   - DFS 1회 완료마다 지렁이 수(cnt++) 증가  
4. 최종 cnt 출력  

> 🧠 이 코드는 2차원 vector 대신  
> Node 포인터(up/down/left/right)로 연결한 **2D linked grid 구조**를 사용해  
> 저수준 구조체 기반의 그래프 탐색을 직접 구현했다는 점이 핵심이다.

---

## 📊 복잡도 분석

| 항목 | 복잡도 | 설명 |
|------|----------|------|
| ⏱ **시간 복잡도** | O(M × N) | 밭의 모든 칸을 한 번씩 순회하며 DFS 수행 |
| 💾 **공간 복잡도** | O(M × N) | `grid` 노드 포인터 및 `visited` 배열 저장 |
| ⚙️ **DFS 재귀 비용** | O(H) | H = 연결된 배추 덩어리의 크기 (최대 M×N) |
| 🚀 **탐색 구조** | DFS 기반 연결 요소 탐색 (Connected Components) |
| 🔁 **최적화 요소** | 방문 배열(`visited`)을 이용한 중복 탐색 방지 |

---

## 🧩 결과 요약표

| 항목 | 내용 |
|------|------|
| 🧾 **문제 번호** | 1012 |
| 📛 **문제 이름** | 유기농 배추 (Organic Cabbage) |
| 🥇 **난이도** | Silver II |
| 💻 **사용 언어** | C++ |
| 🧠 **알고리즘 분류** | 그래프 탐색, DFS, BFS |
| 🧩 **핵심 개념** | 상하좌우 인접한 배추의 연결 요소 탐색 |
| ⏱ **시간 복잡도** | O(M × N) |
| 💾 **공간 복잡도** | O(M × N) |
| ⚡ **입출력 최적화** | `ios::sync_with_stdio(false); cin.tie(nullptr);` |
| 📤 **출력 형태** | 각 테스트케이스마다 지렁이(연결 요소) 수 출력 |
| 🎯 **학습 포인트** | DFS 구조 이해 및 연결된 컴포넌트 개수 세기 패턴 |

---

## 💬 느낀점
- 기존의 2D 배열 방식보다 **포인터 기반 구조(Node grid)** 로 구현하면서  
  메모리 구조와 탐색 로직을 저수준에서 직접 다뤄볼 수 있었다.  
- DFS의 **인덱스 경계 처리(i < 0, j < 0 등)** 의 중요성을 깨달았다.  
- “논리적으로는 안전해 보여도 실제 인덱스 접근은 위험할 수 있다”는 점을 체감했다.  
- 구조체 + 포인터를 이용한 그래프 구현은 추상적인 자료구조 개념을  
  **직접 눈으로 그릴 수 있게 해준다.**

---

