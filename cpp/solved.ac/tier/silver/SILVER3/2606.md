# 🦠 백준 2606 — 바이러스

> 💻 **문제 유형:** 그래프 탐색 (DFS)  
> 🧮 **난이도:** Silver III  
> 🕒 **시간 제한:** 1초  
> 💾 **메모리 제한:** 128MB  

---

## 📘 문제

한 컴퓨터가 바이러스에 걸리면 **연결된 모든 컴퓨터로 바이러스가 전염**된다.  
1번 컴퓨터가 바이러스에 걸렸을 때,  
**바이러스에 걸리게 되는 컴퓨터의 수**를 구하라.

---

## 📥 입력

- 첫째 줄: 컴퓨터의 수 `C` (1 ≤ C ≤ 100)  
- 둘째 줄: 네트워크 상에서 연결된 컴퓨터 쌍의 수 `T`  
- 다음 `T`개의 줄: 각 줄에 연결된 두 컴퓨터 번호 `a`, `b`

---

## 📤 출력

- 1번 컴퓨터가 바이러스에 걸렸을 때,  
  **전염되는 컴퓨터의 수** (1번 제외)
  
---

## 💡 핵심 개념

| 개념 | 설명 |
|------|------|
| **그래프 탐색** | 각 컴퓨터를 노드로, 연결을 간선으로 표현 |
| **DFS (깊이 우선 탐색)** | 연결된 노드를 재귀적으로 탐색하며 감염 확산 |
| **방문 배열(visited)** | 이미 감염된 노드를 중복 방문하지 않기 위해 사용 |

---

## 🔍 접근 방법

1. **그래프 표현**
   - `vector<vector<int>> adj`로 인접 리스트를 생성  
   - 양방향 연결이므로 `adj[a].push_back(b)`와 `adj[b].push_back(a)`

2. **DFS 탐색**
   - 1번 컴퓨터에서 시작 (`DFS(1)`)
   - 방문하지 않은 노드를 재귀적으로 탐색
   - 새로 감염될 때마다 `virus++`

3. **결과 출력**
   - 감염된 컴퓨터의 개수(`virus`)를 출력  
   - (1번 컴퓨터 자신은 제외)

---

## 🧩 복잡도 분석

| 항목 | 복잡도 | 설명 |
|------|----------|------|
| ⏱ **시간 복잡도** | O(N + E) | 모든 노드와 간선을 한 번씩 DFS로 탐색 |
| 💾 **공간 복잡도** | O(N + E) | 인접 리스트(adj)와 방문 배열(visited) 사용 |
| ⚙️ **재귀 호출 비용** | O(N) | DFS 깊이가 최대 노드 수(N)까지 가능 |
| 🚀 **탐색 구조** | DFS 기반 그래프 탐색 (깊이 우선 탐색) |
| 🔁 **최적화 요소** | 방문 여부를 boolean 배열로 즉시 판정하여 중복 탐색 방지 |

---

## 📊 결과 요약표

| 항목 | 내용 |
|------|------|
| **문제 번호** | 2606 |
| **문제 이름** | 바이러스 |
| **난이도** | Silver III |
| **사용 언어** | C++ |
| **알고리즘 분류** | 그래프 탐색 (DFS), 인접 리스트 |
| **핵심 개념** | 깊이 우선 탐색(DFS)으로 연결 컴퓨터 탐색 |
| **시간 복잡도** | O(N + E) |
| **공간 복잡도** | O(N + E) |
| **입출력 최적화** | `ios::sync_with_stdio(false); cin.tie(nullptr);` |
| **출력 형태** | 감염된 컴퓨터의 수 출력 (1번 제외) |
| **학습 포인트** | DFS의 구조, 방문 배열 관리, 양방향 그래프 연결 방식 |

---

## 🧠 느낀점

- DFS의 기본 구조를 복습하기에 아주 좋은 문제였다.  
- 연결 그래프를 구현할 때 **양방향 연결**을 잊지 않는 것이 중요했다.  
- `visited` 배열을 관리하지 않으면 무한 루프에 빠질 수 있다는 점도 다시 한 번 확인할 수 있었다.  
- 이 문제를 통해 그래프 탐색의 기본기를 확실히 다질 수 있었다.  

