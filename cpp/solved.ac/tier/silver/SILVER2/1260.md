# 🚀 BOJ 1260 — DFS와 BFS

> 📂 **카테고리:** 그래프 탐색 (DFS, BFS)  
> 💻 **언어:** C++  
> 🏷️ **태그:** DFS, BFS, Graph, Recursion, Queue, BOJ1260, Silver II, C++, 탐색, ConnectedComponents

---

## 🧩 문제

그래프를 DFS(깊이 우선 탐색)과 BFS(너비 우선 탐색)로 탐색한 결과를 출력하는 프로그램을 작성하시오.  
단, 방문할 수 있는 정점이 여러 개인 경우, **정점 번호가 작은 것부터** 방문한다.

---

## 📥 입력

첫째 줄에 정점의 개수 `N`, 간선의 개수 `M`, 탐색을 시작할 정점 번호 `V`가 주어진다.  
둘째 줄부터 M개의 줄에는 간선이 연결하는 두 정점의 번호 `a`, `b`가 주어진다.  
(양방향 그래프)


---

## 📤 출력

첫째 줄에 **DFS** 수행 결과,  
둘째 줄에 **BFS** 수행 결과를 출력한다.


---

## 🧠 핵심 개념

| 개념 | 설명 |
|------|------|
| **DFS (Depth First Search)** | 한 노드에서 출발해 깊게 들어가며 탐색하는 방식. 재귀 또는 스택 사용. |
| **BFS (Breadth First Search)** | 한 노드에서 출발해 가까운 노드부터 탐색하는 방식. 큐 사용. |
| **인접 리스트 (Adjacency List)** | 각 정점에 연결된 노드를 리스트로 표현. 메모리 효율적. |
| **방문 배열 (visited)** | 방문 여부를 체크하여 중복 탐색 방지. |

---

## 🧭 접근 방법

1. **그래프 표현:**  
   `vector<Node*>`를 사용하여 각 노드의 연결관계를 인접 리스트로 저장.  
2. **DFS 구현:**  
   재귀 함수를 통해 방문하지 않은 노드를 깊이 우선으로 탐색.  
3. **BFS 구현:**  
   큐를 사용하여 가까운 정점부터 차례로 탐색.  
4. **정렬 처리:**  
   정점 번호가 작은 것부터 방문해야 하므로 `sort()`로 인접 리스트 정렬.  
5. **visited 배열 초기화:**  
   DFS 이후 BFS를 수행할 때 다시 초기화 필요.
   
---

## 💬 느낀점

> DFS와 BFS의 차이를 코드로 직접 구현하며,  
> **재귀 vs 큐 구조**의 흐름을 명확히 이해할 수 있었다.  
> 특히 방문 순서를 오름차순으로 맞추기 위한 `sort()` 정렬이 핵심 포인트였다.  
>  
> 단순 탐색이라도 구조체(`Node`)와 클래스(`Graph`)로 설계하면  
> **확장성과 가독성**이 확실히 좋아진다는 점을 체감했다.
