# 숨바꼭질 (BOJ 1697)

> 📂 **카테고리:** 그래프 탐색 / BFS  
> 💻 **언어:** C++  
> 🏷️ **태그:** BFS, 최단거리, 큐, 방문배열, BOJ1697, 실버1

---

## 🧩 문제
수빈이는 동생을 찾아 1초마다 이동할 수 있다.  
한 번에 갈 수 있는 위치는 **현재 위치에서 +1, -1, 또는 ×2** 중 하나이다.  
수빈이가 있는 위치 `N`과 동생이 있는 위치 `K`가 주어졌을 때,  
수빈이가 동생을 찾을 수 있는 **최소 시간**을 구하라.

---

## 🧮 입력

- `0 ≤ N, K ≤ 100,000`

---

## 💬 출력

- 수빈이가 동생을 찾는 최소 시간 (초)

---

## 💡 핵심 개념
- **그래프 탐색 (BFS)**  
  → 모든 이동의 가중치가 동일하므로, BFS로 탐색하면 **가장 먼저 도달한 경로가 최단 경로**.  
- **큐(queue)**를 이용한 레벨 단위 탐색 (1레벨 = 1초)
- **visited 배열**로 중복 방문 방지

---

## 🚀 접근 방법

| 단계 | 내용 |
|------|------|
| ① | 시작점 `S`를 큐에 삽입하고 방문 표시 |
| ② | 큐에서 현재 위치(`cnum`)를 꺼내고, 세 방향으로 이동 (`+1, -1, *2`) |
| ③ | 이동 가능한 위치(`0 ≤ j ≤ 100000`) 중 미방문 노드만 큐에 삽입 |
| ④ | 각 큐의 레벨(한 번의 전체 탐색)을 1초로 간주하여 `time++` 증가 |
| ⑤ | 목표 `B`를 만나면 즉시 종료, 누적 시간 출력 |

---

## 📊 복잡도 분석

| 항목 | 복잡도 | 설명 |
|------|----------|------|
| ⏱ **시간 복잡도** | **O(N)** | 모든 위치(0~100,000)를 최대 한 번씩 방문 |
| 💾 **공간 복잡도** | **O(N)** | 방문 배열(`visited`) + 큐(`queue<int>`) 공간 포함 |
| ⚙️ **탐색 깊이 단위** | BFS의 레벨(Level) = 1초 단위 |
| 🚀 **탐색 구조** | 큐(Queue) 기반 너비 우선 탐색 (Breadth-First Search) |
| 🔁 **최적화 요소** | 방문 배열로 중복 탐색 방지, 즉시 종료(`return`) 처리 |
| ⚡ **입출력 최적화** | `ios::sync_with_stdio(false);` + `cin.tie(nullptr);` 사용 |

---

## 🧩 결과 요약표

| 항목 | 내용 |
|------|------|
| 🧾 **문제 번호** | 1697 |
| 📛 **문제 이름** | 숨바꼭질 |
| 🥇 **난이도** | Silver I |
| 💻 **사용 언어** | C++ |
| 🧠 **알고리즘 분류** | 그래프 탐색, BFS (너비 우선 탐색) |
| 🧩 **핵심 개념** | 동일 가중치 그래프에서 BFS는 최단 시간을 보장 |
| ⏱ **시간 복잡도** | O(N) |
| 💾 **공간 복잡도** | O(N) |
| ⚙️ **탐색 방식** | BFS (큐 기반) |
| 📤 **출력 형태** | 최소 이동 시간 (정수 1개) |
| 🎯 **학습 포인트** | 레벨 단위 탐색 구조, visited 처리 타이밍의 중요성 |

---

## 💭 느낀점

이번 문제를 통해 **BFS의 ‘레벨 구조 = 시간 단위’**라는 개념을 확실히 체득했다.  
처음에는 단순 반복문으로 접근했지만,  
`visited` 배열과 `roop = q.size()` 구조의 중요성을 깨닫고 나서  
탐색이 깔끔하게 한 번씩만 진행되며 최단 시간이 정확히 산출되었다.  

또한, BFS의 장점인 “최초 도달이 최단 거리” 원리를 코드로 직접 체감할 수 있었다.  
앞으로 그래프나 경로 탐색 문제를 풀 때  
**‘가중치가 동일하면 BFS, 다르면 Dijkstra’** 라는 선택 기준을 명확히 세우게 되었다.  

> 🔍 **핵심 한 줄 요약:** BFS는 “레벨 단위 탐색이 곧 최소 시간 계산”임을 완벽히 이해한 문제였다.
