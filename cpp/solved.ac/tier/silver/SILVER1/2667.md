# 🏠 BOJ 2667 단지번호붙이기 (C++)

## 📘 문제
정사각형 지도에서 `1`은 집이 있는 곳, `0`은 집이 없는 곳을 나타낸다.  
상하좌우로 연결된 집들의 집합을 **단지**라 하며,  
지도의 모든 단지 수와 각 단지의 집의 수를 오름차순으로 출력하라.

---

## ⌨️ 입력
- 첫째 줄: 지도의 크기 `N (5 ≤ N ≤ 25)`
- 다음 `N`개의 줄: `0`과 `1`로 이루어진 문자열 (지도 정보)

---

## 🖥️ 출력
- 첫째 줄: 총 단지의 개수
- 이후: 각 단지에 속한 집의 수를 오름차순으로 한 줄에 하나씩 출력
## 🧩 핵심 개념
- **그래프 탐색 (BFS or DFS)**  
- **2차원 배열에서 연결 요소(connected component) 탐색**  
- **방문 처리로 중복 탐색 방지**

---

## 🚀 접근 방법
1. 입력받은 `N×N` 지도에서 `1`을 발견하면 BFS(또는 DFS)로 연결된 모든 집 탐색  
2. 탐색 중 방문한 집은 `0`으로 변경하여 재방문 방지  
3. 한 번의 BFS가 끝날 때마다 단지 하나 완성 → 단지 크기 저장  
4. 모든 탐색이 끝나면 단지 개수와 크기를 오름차순으로 출력

---

## 📊 복잡도 분석

| 항목 | 복잡도 | 설명 |
|------|----------|------|
| ⏱ **시간 복잡도** | O(N × N) | 지도 전체를 한 번씩 방문하며 BFS 수행 |
| 💾 **공간 복잡도** | O(N × N) | `field` 2D 배열 및 BFS 큐 공간 사용 |
| ⚙️ **BFS 탐색 깊이** | O(H) | H = 하나의 단지 내 집의 개수 (최대 N×N) |
| 🚀 **탐색 구조** | BFS 기반 연결 요소 탐색 (Connected Components) |
| 🔁 **최적화 요소** | 방문 시 즉시 `0`으로 변경하여 중복 탐색 방지 |

---

## 🧩 결과 요약표

| 항목 | 내용 |
|------|------|
| **문제 번호** | 2667 |
| **문제 이름** | 단지번호붙이기 (Numbering Complexes) |
| **난이도** | Silver I |
| **사용 언어** | C++ |
| **알고리즘 분류** | 그래프 탐색, BFS, DFS |
| **핵심 개념** | 2D 연결 요소 탐색, BFS 큐 활용 |
| **시간 복잡도** | O(N × N) |
| **공간 복잡도** | O(N × N) |
| **입출력 최적화** | `ios::sync_with_stdio(false); cin.tie(nullptr);` |
| **출력 형태** | 단지 개수 및 각 단지별 집의 수(오름차순) 출력 |
| **학습 포인트** | BFS로 연결된 영역 탐색, 방문 처리 방식, 정렬 결과 출력 |

---

## 💬 느낀점

- 그래프 탐색의 기본 구조를 완전히 이해할 수 있는 문제였다.  
- BFS를 통해 **인접 노드 탐색 + 방문 처리** 패턴을 연습하기에 적합했다.  
- DFS로도 해결 가능하지만, BFS는 큐 구조 덕분에 구현이 더 직관적이었다.  
- 문제의 입력 형태(`문자열 → 숫자 변환`)와 방문 처리(`field[nx][ny] = 0`)가 핵심 포인트였다.  
- 비슷한 유형의 문제(섬의 개수, 유기농 배추 등) 대비 학습용으로 매우 유익했다.
