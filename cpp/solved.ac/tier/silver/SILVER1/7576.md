# 🍅 Baekjoon 7576 — 토마토 (BFS)

> 📂 **분류:** 그래프 탐색 / BFS  
> 💻 **언어:** C++  
> 🧠 **레벨:** Gold V  
> 🧾 **문제 번호:** [Baekjoon 7576](https://www.acmicpc.net/problem/7576)

---

## 🧩 문제

하루가 지나면, 익은 토마토(1)의 상하좌우 인접한 토마토가 익는다.  
창고에 저장된 모든 토마토가 며칠이 지나면 익게 되는지를 계산하라.  
만약 일부 토마토가 끝내 익지 못하면 `-1`을 출력한다.

---

## 💡 입력

- 첫 줄: `N M`  
  (N: 가로 칸 수, M: 세로 칸 수)  
- 둘째 줄부터 M개의 줄:  
  M행 N열의 격자  
  - `1`: 익은 토마토  
  - `0`: 익지 않은 토마토  
  - `-1`: 빈 칸  

---

## 📤 출력

- 모든 토마토가 익는 데 걸리는 **최소 일수**  
- 단, 모두 익지 못하는 경우 `-1`

---

## 🔑 핵심 개념

| 개념 | 설명 |
|------|------|
| **그래프 탐색 (BFS)** | 큐를 이용해 익은 토마토에서 동시에 퍼져나가는 방식 구현 |
| **Flood Fill 원리** | 여러 시작점(익은 토마토)에서 동시에 4방향 전파 |
| **레벨 단위 BFS** | BFS 한 단계가 “하루”에 해당 |
| **상태 변화 관리** | 익히면서 바로 `1`로 업데이트, 중복 방문 방지 |

---

## 🚀 접근 방법

1. **초기화**
   - 모든 익은 토마토(1)를 큐에 미리 삽입한다.
   - 익지 않은 토마토(0)의 개수를 `unripe`로 세어둔다.

2. **BFS 진행**
   - 큐의 한 레벨을 “하루”로 보고, 현재 큐 크기(`sz`)만큼 반복.
   - 4방향(상하좌우)에 대해 인접 토마토를 익힌다.
   - 새로운 토마토가 익을 때마다 `unripe--`.

3. **종료 조건**
   - 큐가 빌 때까지 반복.
   - 모든 토마토가 익었으면 걸린 `days` 출력.
   - 아직 `unripe > 0`이면 `-1` 출력.

---

## 📊 복잡도 분석

| 항목 | 복잡도 | 설명 |
|------|---------|------|
| ⏱ **시간 복잡도** | **O(M × N)** | 모든 칸(정점)을 최대 한 번씩만 방문 (BFS 1회 순회) |
| 💾 **공간 복잡도** | **O(M × N)** | 격자 배열(box) + 큐(queue) 저장 공간 |
| ⚙️ **BFS 단계 수** | **O(D)** | D = 익는 데 걸린 일수 (최대 M×N 단계) |
| 🚀 **탐색 구조** | **BFS (Queue 기반)** | 여러 시작점에서 동시에 전파 (멀티 소스 BFS) |
| 🔁 **최적화 요소** | **unripe 카운터**를 통한 실시간 종료 감지, 불필요한 비교 제거 |
| ⚡ **입출력 최적화** | `ios::sync_with_stdio(false); cin.tie(nullptr);` 사용 |

---

## 🧩 결과 요약표

| 항목 | 내용 |
|------|------|
| 🧾 **문제 번호** | 7576 |
| 📛 **문제 이름** | 토마토 |
| 🥇 **난이도** | Gold V |
| 💻 **사용 언어** | C++ |
| 🧠 **알고리즘 분류** | 그래프 탐색 (BFS), Flood Fill |
| 🔑 **핵심 개념** | 여러 시작점에서 동시에 전파하는 레벨 단위 BFS |
| ⏱ **시간 복잡도** | O(M × N) |
| 💾 **공간 복잡도** | O(M × N) |
| ⚙️ **탐색 방식** | 큐 기반 BFS (동시 확산) |
| 📤 **출력 형태** | 걸린 일수 or -1 |
| 🎯 **학습 포인트** | BFS를 시간의 흐름으로 해석하는 사고 방식 익히기 |
